<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>process进度变换</title>
</head>
<body>
  <canvas id="level" style="width: 100%;" class="level"></canvas>
<script>
  const levelList = [{
    text: '黄铜',
    title: '0分',
    val: 0
  }, {
    text: '白银',
    title: '50分',
    val: 50
  }, {
    text: '黄金',
    title: '200分',
    val: 200
  }, {
    text: '白金',
    title: '350分',
    val: 350
  }, {
    text: '钻石',
    title: '800分',
    val: 800
  }]
  class Level {
    constructor ({
      canvasWidth,
      canvasHeight,
      scale,
      processWidth,
      processHeight,
      imageList,
      startX,
      startY,
      processRuntimeHeight,
      currentColor,
      previousColor,
      levelList,
      imageSize,
    }) {
      // 画布宽度
      this.canvasWidth = canvasWidth
      // 画布高度
      this.canvasHeight = canvasHeight
      // 页面dpr
      this.scale = scale
      // 进度条整体长度
      this.processWidth = processWidth
      // 进度条整体高度
      this.processHeight = processHeight
      // 不同等级图标
      this.imageList = imageList
      // 等级列表
      this.levelList = levelList
      // 开始x位置
      this.startX = startX
      // 开始y位置
      this.startY = startY
      // 进度条展示的高度
      this.processRuntimeHeight = processRuntimeHeight
      // 当前月份积分颜色
      this.currentColor = currentColor
      // 上月份积分颜色
      this.previousColor = previousColor
      // 进度条整体颜色
      this.LineColor = '#E6E6E6'
      // 文本颜色
      this.textColor = '#878C9B'
      // 图标大小
      this.imageSize = imageSize
    }
    // 绘制整体进度条
    renderLine (ctx) {
      ctx.beginPath()
      ctx.fillStyle = this.LineColor
      ctx.rect(this.startX, this.startY, this.processWidth, this.processHeight)
      ctx.fill()
      ctx.closePath()
    }
    /**
     * 绘制进度条进度
     * @param {CanvasContext} ctx canvas上下文
     * @param {boolean} isCurrent 是否当前进度条
     * @param {number} width 进度条的长度
     * @param {number} tipHeight 说明文案虚线高度
     */
    renderProcess (ctx, isCurrent, width, tipHeight) {
      const color = isCurrent ? this.currentColor : this.previousColor
      ctx.beginPath()
      ctx.fillStyle = color
      ctx.moveTo(this.startX, this.startY)
      ctx.lineTo(this.startX + width, this.startY)
      ctx.lineTo(this.startX + width - this.processRuntimeHeight, this.startY + this.processRuntimeHeight)
      ctx.lineTo(this.startX, this.startY + this.processRuntimeHeight)
      ctx.fill()
      ctx.closePath()
    }
    /**
     * 绘制提示信息
     * @param {CanvasContext} ctx canvas上下文
     * @param {number} x 绘制坐标的x
     * @param {number} y 绘制坐标的y
     * @param {number} lineHeight 说明文案虚线高度
     * @param {boolean} isCurrent 是否当前进度条
     * @param {string} text 提示文案
     */
    renderScoreTip (ctx, x, y, lineHeight, isCurrent, text) {
      const color = isCurrent ? this.currentColor : this.previousColor
      ctx.beginPath()
      ctx.setLineDash([3 * this.scale, 3 * this.scale])
      ctx.lineWidth = 2 * this.scale
      ctx.strokeStyle = color
      ctx.moveTo(x, y)
      ctx.lineTo(x, y - lineHeight)
      ctx.stroke()
      ctx.moveTo(x, y - lineHeight - 5 * this.scale)
      const rectWidth = 60 * this.scale
      const rectHeight = 24 * this.scale
      // 画圆角的矩形
      this.roundRect(ctx, color, x - rectWidth / 2, y - lineHeight - rectHeight - 2 * this.scale, rectWidth, rectHeight, 2 * this.scale)
      // 画提示文字
      this.renderText(ctx, text, `${this.scale * 12}px PingFangSC-Medium`, '#fff', x, y - lineHeight - rectHeight / 2 + 2 * this.scale)
      ctx.closePath()
    }
    // 获取排序的异步图片资源
    async getRenderImageList () {
      const length = this.levelList.length
      const imageRenderList = []
      for (let i = 0; i < length; i++) {
        imageRenderList.push(this.getImageData(this.imageList[i]))
      }
      return Promise.all(imageRenderList)
    }
    // 单个图片promise化
    getImageData (data) {
      return new Promise((resolve, reject) => {
        const img = new Image()
        img.src = data
        img.onload = () => {
          resolve(img)
        }
      })
    }
    // 绘制进度条框架
    renderLevelList (ctx, imageRenderList) {
      const length = imageRenderList.length
      const perWidth = this.processWidth / (length - 1)
      for (let i = 0; i < length; i++) {
        ctx.drawImage(imageRenderList[i], this.startX + perWidth * i - this.imageSize / 2, this.startY - this.imageSize / 2, this.imageSize, this.imageSize)
        this.renderText(ctx, this.levelList[i].title, `${this.scale * 12}px PingFangSC-Regular`, this.textColor, this.startX + perWidth * i, this.startY - this.imageSize / 2 + 40 * this.scale)
        this.renderText(ctx, this.levelList[i].text, `${this.scale * 13}px PingFangSC-Regular`, this.textColor, this.startX + perWidth * i, this.startY - this.imageSize / 2 + 60 * this.scale)
      }
    }
    /**
     * @param {CanvasContext} ctx canvas上下文
     * @param {number} x 圆角矩形选区的左上角 x坐标
     * @param {number} y 圆角矩形选区的左上角 y坐标
     * @param {number} w 圆角矩形选区的宽度
     * @param {number} h 圆角矩形选区的高度
     * @param {number} r 圆角的半径
     */
    roundRect (ctx, color, x, y, w, h, r) {
      ctx.save()
      // 开始绘制
      ctx.beginPath()
      // 因为边缘描边存在锯齿，最好指定使用 transparent 填充
      ctx.fillStyle = color
      // 左上角
      ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5)
      // border-top
      ctx.moveTo(x + r, y)
      ctx.lineTo(x + w - r, y)
      ctx.lineTo(x + w, y + r)
      // 右上角
      ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2)
      // border-right
      ctx.lineTo(x + w, y + h - r)
      ctx.lineTo(x + w - r, y + h)
      // 右下角
      ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5)
      // border-bottom
      ctx.lineTo(x + r, y + h)
      ctx.lineTo(x, y + h - r)
      // 左下角
      ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI)
      // border-left
      ctx.lineTo(x, y + r)
      ctx.lineTo(x + r, y)
      // 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应
      ctx.fill()
      // ctx.stroke()
      ctx.closePath()
      // 剪切
      ctx.clip()
      ctx.restore()
    }
    // 绘制文本
    renderText (ctx, text, font, color, x, y) {
      ctx.font = font
      ctx.textAlign = 'center'
      ctx.fillStyle = color
      ctx.fillText(text, x, y)
    }
  }

  // 2分法查找目标所在区间的index
  function binarySearchIndex (arr = [], target) {
    let left = 0
    let right = arr.length
    while (left <= right) {
      const center = Math.floor((left + right) / 2)
      if (target < arr[center]) {
        right = center - 1
      } else {
        left = center + 1
      }
    }
    return right
  }

  /**
   * 获取运动结束时进度条长度
   * @param {number} score 当前分数
   * @param {number} processWidth 进度条总长度
   * @param {array} levelList 等级数组
   */
  function getProcessResultWidth (score, processWidth, levelList = []) {
    const maxScore = levelList[levelList.length - 1].val
    // 分数负数时处理
    score = score > 0 ? score : 0
    // 分数大于当前最大分数处理
    score = score > maxScore ? maxScore : score
    if (score === maxScore) {
      return processWidth
    }
    const scoreList = levelList.map(li => li.val)
    const index = binarySearchIndex(scoreList, score)
    // 每份的长度
    const perWidth = processWidth / (scoreList.length - 1)
    // 区间长度
    const blockWidth = scoreList[index + 1] - scoreList[index]
    // 所在区间当前分数的长度
    const matchWidth = score - scoreList[index]
    return perWidth * index + matchWidth / blockWidth * perWidth
  }
  async function handler () {
    const levelCanvas = document.getElementById('level')
    // 获取当前style样式的宽高
    const canvasStyle = levelCanvas.getBoundingClientRect()
    const ctx = levelCanvas.getContext('2d')
    const {
      width,
      height
    } = canvasStyle
    // 当前dpr
    const scale = window.devicePixelRatio || 3
    // 画布的宽度进行等比缩放
    const canvasWidth = width * scale
    // 画布的高度进行等比缩放
    const canvasHeight = height * scale
    levelCanvas.width = canvasWidth
    levelCanvas.height = canvasHeight
    const startX = 34 * scale
    const startY = 85 * scale
    const processWidth = canvasWidth - startX * 2
    const processHeight = 4 * scale
    const processRuntimeHeight = 6 * scale
    const imageSize = 24 * scale
    const currentColor = '#F94C09'
    const previousColor = '#BBBBBB'
    const currentScore = 720
    const previousScore = 700
    const currentWidth = getProcessResultWidth(currentScore, processWidth, levelList)
    const previousWidth = getProcessResultWidth(previousScore, processWidth, levelList)
    const currentText = `本月${currentScore}分`
    const previousText = `上月${previousScore}分`
    const imageList = [
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_0.png',
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_1.png',
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_2.png',
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_3.png',
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_4.png',
      'https://erp-1258916733.cos.ap-shanghai.myqcloud.com/knight-h5/phase/phaseLevel_5.png',
    ]
    const level = new Level({
      canvasWidth,
      canvasHeight,
      scale,
      processWidth,
      processHeight,
      startX,
      startY,
      processRuntimeHeight,
      imageSize,
      imageList,
      currentColor,
      previousColor,
      levelList,
    })
    // 拿到排序好的图标列表缓存起来
    const imageRenderList = await level.getRenderImageList()
    let currentRuntimeWidth = 0
    let previousRuntimeWidth = 0
    // 计算全部长度速度(processWidth大小与列表最大分数值没关系，只与屏幕宽度有关)
    const totalSpeed = 10 / processWidth
    let currentSpeed = currentWidth * totalSpeed
    let previousSpeed = previousWidth * totalSpeed
    let timer
    ;(function run () {
      if (previousRuntimeWidth <= previousWidth || currentRuntimeWidth <= currentWidth) {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight)
        level.renderLine(ctx)
        level.renderProcess(ctx, false, previousRuntimeWidth, 12 * scale, previousText)
        level.renderProcess(ctx, true, currentRuntimeWidth, 40 * scale, currentText)
        level.renderScoreTip(ctx, startX + currentRuntimeWidth, startY - 4 * scale, 40 * scale, true, currentText)
        level.renderScoreTip(ctx, startX + previousRuntimeWidth, startY - 4 * scale, 12 * scale, false, previousText)
        if (previousRuntimeWidth < previousWidth) {
          previousRuntimeWidth += previousSpeed
        } else {
          previousRuntimeWidth = previousWidth
        }
        if (currentRuntimeWidth <= currentWidth) {
          currentRuntimeWidth += currentSpeed
        } else {
          currentRuntimeWidth = currentWidth
        }
        level.renderLevelList(ctx, imageRenderList)
        // 防止死循环
        if (currentRuntimeWidth < currentWidth || previousRuntimeWidth < previousWidth) {
          timer = requestAnimationFrame(run)
        }
      } else {
        cancelAnimationFrame(timer)
      }
    })()
  }
  handler()
</script>
</body>
</html>